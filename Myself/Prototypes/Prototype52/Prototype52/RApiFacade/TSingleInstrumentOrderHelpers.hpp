#pragma once

#include "./TSingleInstrumentOrder.hpp"

#include "../Common/SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace RApiFacade
{
   //

//TODO Refactoring needed? The interface appears to be OK. But pay special attention to methods that use order state bitmask.
   class TSingleInstrumentOrderHelpers abstract sealed
   {
#if( /* //{(private)} Instance default constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* //{(private)} Instance copy constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* //{(private) operator =}. */ 1 )

      // Cannot be autogenerated.

#endif

#if( /* {public OrdersStateBitMaskEqual}. */ 1 )

      // {TSingleInstrumentsOrdersPointerIterator_} should be a {const} iterator.

      public:
         template
            < typename TSingleInstrumentsOrdersPointerIterator_
            >
         static bool OrdersStateBitMaskEqual
// TODO 2 yg? These should be reference iterators.
            ( TSingleInstrumentsOrdersPointerIterator_ orders1BeginIterator,
              TSingleInstrumentsOrdersPointerIterator_ orders1EndIterator,
              TOrderStateBitMask orderStateBitMask
            );

#endif
#if( /* {public OrdersStateBitMaskEqual}. */ 1 )

      // An overload. Same comments apply.

      public:
         template
            < typename TSingleInstrumentsOrdersPointerIterator_
            >
         static bool OrdersStateBitMaskEqual
// TODO 2 yg? These should be reference iterators.
            ( TSingleInstrumentsOrdersPointerIterator_ orders1BeginIterator,
              TSingleInstrumentsOrdersPointerIterator_ orders1EndIterator,
              TOrderStateBitMask orderStateBitMaskBitMask,
              TOrderStateBitMask orderStateBitMask
            );

#endif
#if( /* {public OrderStateBitMaskExists}. */ 1 )

      // {TSingleInstrumentsOrdersPointerIterator_} should be a {const} iterator.

      public:
         template
            < typename TSingleInstrumentsOrdersPointerIterator_
            >
         static bool OrderStateBitMaskExists
// TODO 2 yg? These should be reference iterators.
            ( TSingleInstrumentsOrdersPointerIterator_ orders1BeginIterator,
              TSingleInstrumentsOrdersPointerIterator_ orders1EndIterator,
              TOrderStateBitMask orderStateBitMask
            );

#endif
#if( /* {public OrderStateBitMaskExists}. */ 1 )

      // An overload. Same comments apply.

      public:
         template
            < typename TSingleInstrumentsOrdersPointerIterator_
            >
         static bool OrderStateBitMaskExists
// TODO 2 yg? These should be reference iterators.
            ( TSingleInstrumentsOrdersPointerIterator_ orders1BeginIterator,
              TSingleInstrumentsOrdersPointerIterator_ orders1EndIterator,
              TOrderStateBitMask orderStateBitMaskBitMask,
              TOrderStateBitMask orderStateBitMask
            );

#endif
#if( /* {public OrdersStateBitMaskExist}. */ 1 )

      // Assumption: {numberOrdersMinLimit > ::std::numeric_limits< int >::lowest()}.
      // {TSingleInstrumentsOrdersPointerIterator_} should be a {const} iterator.

      public:
         template
            < typename TSingleInstrumentsOrdersPointerIterator_
            >
         static bool OrdersStateBitMaskExist
// TODO 2 yg? These should be reference iterators.
            ( TSingleInstrumentsOrdersPointerIterator_ orders1BeginIterator,
              TSingleInstrumentsOrdersPointerIterator_ orders1EndIterator,
              TOrderStateBitMask orderStateBitMask,
              int numberOrdersMinLimit
            );

#endif
#if( /* {public OrdersStateBitMaskExist}. */ 1 )

      // An overload. Same comments apply.

      public:
         template
            < typename TSingleInstrumentsOrdersPointerIterator_
            >
         static bool OrdersStateBitMaskExist
// TODO 2 yg? These should be reference iterators.
            ( TSingleInstrumentsOrdersPointerIterator_ orders1BeginIterator,
              TSingleInstrumentsOrdersPointerIterator_ orders1EndIterator,
              TOrderStateBitMask orderStateBitMaskBitMask,
              TOrderStateBitMask orderStateBitMask,
              int numberOrdersMinLimit
            );

#endif

#if( /* {public CanModifyOrder}. */ 1 )

      //
      
      public: static bool CanModifyOrder
         ( TSingleInstrumentOrder const & order1
         );

#endif
#if( /* {public CanModifyOrders}. */ 1 )

      // {TSingleInstrumentsOrdersPointerIterator_} should be a {const} iterator.
      // yg? We might need separate methods to check if all orders meet a condition, at least 1 order meets a condition,
      // yg? at least a given number of orders meet a condition. We can use the words "all" and "any". But we already have "as any".
      // yg? Maybe use the word "exists" and/or "exist", like with the methods that compare order state bitmasks.

      public:
         template
            < typename TSingleInstrumentsOrdersPointerIterator_
            >
         static bool CanModifyOrders
// TODO 2 yg? These should be reference iterators.
            ( TSingleInstrumentsOrdersPointerIterator_ orders1BeginIterator,
              TSingleInstrumentsOrdersPointerIterator_ orders1EndIterator
            );

#endif
#if( /* {public CanCancelOrder}. */ 1 )

      // See also: {InternalCanCancelOrder}.
      
      public: static bool CanCancelOrder
         ( TSingleInstrumentOrder const & order1
         );

#endif
#if( /* {public CanCancelOrders}. */ 1 )

      // yg? {CanModifyOrders} comments apply.

      public:
         template
            < typename TSingleInstrumentsOrdersPointerIterator_
            >
         static bool CanCancelOrders
// TODO 2 yg? These should be reference iterators.
            ( TSingleInstrumentsOrdersPointerIterator_ orders1BeginIterator,
              TSingleInstrumentsOrdersPointerIterator_ orders1EndIterator
            );

#endif
#if( /* {public InternalCanCancelOrder}. */ 1 )

      // See also: {CanCancelOrder}.
      
      public: static bool InternalCanCancelOrder
         ( TSingleInstrumentOrder const & order1
         );

#endif
#if( /* {public ShallAndInternalCanCancelOrder}. */ 1 )

      //
      
      public: static bool ShallAndInternalCanCancelOrder
         ( TSingleInstrumentOrder const & order1
         );

#endif
#if( /* {public CanCancelOrderAsAny}. */ 1 )

      // Returns {true} if an "any" order cancellation request would likely try to cancel a given order.
      
      public: static bool CanCancelOrderAsAny
         ( TSingleInstrumentOrder const & order1
         );

#endif
#if( /* {public RegisterRequestCancelOrderAsAnyIfCan}. */ 1 )

      //
      
      public: static void RegisterRequestCancelOrderAsAnyIfCan
         ( TSingleInstrumentOrder & order1
         );

#endif
#if( /* {public RegisterRequestCancelOrdersAsAnyIfCan}. */ 1 )

      // {orders1} is not declared {const} as it owns the order objects and this method can modify them.
      // TODO 3 yg? Passing the whole map reference. But can we use a sliced map item iterator?
      // TODO 3 yg? Would {::boost::make_transform_iterator} be helpful?
      // Some comments apply to {TRApiHelpers::RequestCancelAnyOrders}.

      public:
         //template
         //   < typename TSingleInstrumentsOrdersPointerIterator_
         //   >
         static void RegisterRequestCancelOrdersAsAnyIfCan
            ( //TSingleInstrumentsOrdersPointerIterator_ orders1BeginIterator,
              //TSingleInstrumentsOrdersPointerIterator_ orders1EndIterator
// TODO 2 yg? This map should contain order object references. Can we use {::std::reference_wrapper}?
              ::std::map< void const *, ::std::unique_ptr< TSingleInstrumentOrder > > & orders1
            );

#endif
   };
}
