#pragma once

#include "./TREngineParamsConfiguration.hpp"
#include "./TLogInParamsConfiguration.hpp"
#include "./TAccountInfoConfiguration.hpp"
#include "./TSingleInstrumentOrder.hpp"

#include "../Common/SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace RApiFacade
{
   // yg? Most/all exceptions this class throws are a {::Common::ErrorHandling::TCriticalErrorException}.
   // yg? This is to ensure the app will terminate on an exception.
   // TODO 3 yg? But this should be revisited.

//TODO I haven't tried to check what needs to change. The interface might be OK but some methods, especially order modify/cancel will change.
//TODO The strategy doesn't use this directly.
   class TRApiHelpers abstract sealed
   {
#if( /* {public ConnectPointIdNone}. */ 1 )

      // "None" value for {::RApi::AlertInfo::iConnectionId}.
      // This implies that constants like {TREngineAdapter::TReadinessStateBitMask_MdCnnctPtLoggedInTo_} are {>= ( 1U << 1U )},
      // which we validate with {static_assert}s after {TREngineAdapter::TReadinessStateBitMask_}.
      // And we validate {ConnectPointIdNone} there too.
      public: static int const ConnectPointIdNone = 0;

#endif
#if( /* {public OrderNumberNone}. */ 1 )

      //
      public: static int const OrderNumberNone = 0;

#endif
#if( /* {public OrderReportTextAtomicOrderOperationInProgressAsArray}. */ 1 )

      //
      public: static char const OrderReportTextAtomicOrderOperationInProgressAsArray[];

      //
      private: static void OrderReportTextAtomicOrderOperationInProgressStaticAssertion();

#endif
#if( /* {public OrderReportTextAtomicOrderOperationInProgressLength}. */ 1 )

      //
      public: static int const OrderReportTextAtomicOrderOperationInProgressLength = 34;

#endif

#if( /* //{(private)} Instance default constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* //{(private)} Instance copy constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* //{(private) operator =}. */ 1 )

      // Cannot be autogenerated.

#endif

#if( /* {public AtomicLastChanceHandleException}. */ 1 )

      // This method is similar to its counterparts in the {::Common::ErrorHandling::TErrorHandlingHelpers} class.

      public: static void AtomicLastChanceHandleException
         ( ::OmneException const & exception1
         );

#endif

#if( /* {public TSNCharcbsEqual}. */ 1 )

      // yg? Should we pass a {::tsNCharcb} by reference or by value? It doesn't matter as this method is inline.

      public: static bool TSNCharcbsEqual
         ( ::tsNCharcb const & tsNCharcb1,
           ::tsNCharcb const & tsNCharcb2
         );

#endif
#if( /* {public TSNCharcbEqual}. */ 1 )

      // yg? See another overload comment above.

      public: static bool TSNCharcbEqual
         ( ::tsNCharcb const & tsNCharcb1,
           char const * chars2,
           int chars2Length
         );

#endif
#if( /* {public PopulateNullableTSNCharcb}. */ 1 )

      // This method correctly handles the case when {string1} is empty. If it's not possible call {PopulateTSNCharcb}.
      // TODO 3 yg? We should not need this method; the R|API should not enforce {nullptr} when the length is 0;
      // TODO 3 yg? talk to them about this.
      // yg? See {PopulateTSNCharcb} comment.

      public: static void PopulateNullableTSNCharcb
         ( ::tsNCharcb & tsNCharcb1,
           ::std::string const & string1
         );

#endif
#if( /* {public PopulateTSNCharcb}. */ 1 )

      // Assumption: {string1} is not empty. Otherwise call {PopulateNullableTSNCharcb}.
      // yg? Consider renaming this to {Populate...From...}. Bad idea.
      // yg? Consider renaming this to {Prepare...}.

      public: static void PopulateTSNCharcb
         ( ::tsNCharcb & tsNCharcb1,
           ::std::string const & string1
         );

#endif

#if( /* {public PopulateREngineParams}. */ 1 )

      // yg? Consider renaming this to {Populate...From...}. Bad idea.
      // yg? Consider renaming this to {Prepare...}.

      public: static void PopulateREngineParams
         ( ::RApi::REngineParams & rEngineParams1,
           TREngineParamsConfiguration const & rEngineParamsConfiguration1
         );

#endif
#if( /* //{public CreateREngine}. */ 1 )

      //// It won't help to make {rEngineParams1} an rvalue reference as it would anyway be passed to {::RApi::REngine} as a pointer.
      //// yg? Consider eliminating this method. But I might want to uncomment exception handling.
      //
      //public: static ::RApi::REngine * CreateREngine
      //   ( ::RApi::REngineParams const & rEngineParams1
      //   );

#endif

#if( /* {public LockREngine}. */ 1 )

      //

      public: static void LockREngine
         ( ::RApi::REngine & rEngine1
         );

#endif
#if( /* {public UnlockREngine}. */ 1 )

      //

      public: static void UnlockREngine
         ( ::RApi::REngine & rEngine1
         );

#endif

#if( /* {public PopulateLogInParams}. */ 1 )

      // yg? Consider renaming this to {Populate...From...}. Bad idea.
      // yg? Consider renaming this to {Prepare...}.

      public: static void PopulateLogInParams
         ( ::RApi::LoginParams & logInParams1,
           TLogInParamsConfiguration const & logInParamsConfiguration1
         );

#endif
#if( /* {public AsyncEnsureREngineLoggedIn}. */ 1 )

      // yg? The {::RApi::RCallbacks::Alert} callback is called a few times and the {::RApi::RCallbacks::AccountList} callback
      // yg? is called at least once on the caller and/or another thread before {rEngine1.login} returns, even when {rEngine1} is locked.
      // yg? This is because {rEngine1.login} establishes a "loose" locked block.
      // yg? Consider renaming this method to {Request...}, {TryRequest...}, or {RequestREngineLoggedInIfNeeded}.
      // yg? Actually the {Try...} is inappropriate as this method can throw an exception.

      public: static void AsyncEnsureREngineLoggedIn
         ( ::RApi::REngine & rEngine1,
           ::RApi::LoginParams const & logInParams1
         );

#endif
#if( /* {public AsyncEnsureREngineLoggedOut}. */ 1 )

      // yg? I believe, the operation completes and all designated callbacks are called synchronously,
      // yg? which implies that we should not use the word "async".
      // yg? Consider renaming this method to {RequestREngineLoggedOutIfNeeded} or {AsyncLogOutREngineIfNeeded}.

      public: static void AsyncEnsureREngineLoggedOut
         ( ::RApi::REngine & rEngine1
         );

#endif

#if( /* {public PopulateAccountInfo}. */ 1 )

      // yg? Consider renaming this to {Populate...From...}. Bad idea.
      // yg? Consider renaming this to {Prepare...}.

      public: static void PopulateAccountInfo
         ( ::RApi::AccountInfo & accountInfo1,
           TAccountInfoConfiguration const & accountInfoConfiguration1
         );

#endif

#if( /* {public RequestInstrumentPriceIncrementMinLimit}. */ 1 )

      // yg? Consider renaming this method to {Try...}. Actually the {Try...} is inappropriate as this method can throw an exception.

      public: static void RequestInstrumentPriceIncrementMinLimit
         ( TInstrument const & instrument1
         );

#endif

#if( /* {public RequestSubscribeInstrumentMarketDataIfNeeded}. */ 1 )

      // {instrumentMarketDataTypesBitMask} contains bits such as {::RApi::MD_BEST}.
      // yg? It's easier to subscribe for all market data at once.
      // TODO 3 yg? But test if we can subscribe for quotes and trades with separate calls and refactor the code.
      // TODO 3 yg? But when we unsubscribe the R|API doesn't let us to specify what exactly data to unsubscribe from.
      // TODO 3 yg? Can {::RApi::REngine::suspendInput} help?
      // yg? I've seen the following alert under heavy debugging:
      // yg? 2011-12-12 14:47:10.204101; 0; Error; {RApi::AlertInfo}; CLF2; NYMEX; The subscription to this instrument could not be recovered and has been aborted.; 6; 1; +61; other error
      // TODO 3 yg? So make it possible to restore a lost market data subscription.
      // yg? Consider renaming this method to {Try...}. Actually the {Try...} is inappropriate as this method can throw an exception.

      public: static void RequestSubscribeInstrumentMarketDataIfNeeded
         ( TInstrument const & instrument1,
           int instrumentMarketDataTypesBitMask
         );

#endif
#if( /* {public RequestUnsubscribeInstrumentMarketDataIfNeeded}. */ 1 )

      // yg? Consider using the word "ensure" in this method name. But it would look ugly together wth the word "request".

      public: static void RequestUnsubscribeInstrumentMarketDataIfNeeded
         ( TInstrument const & instrument1
         );

#endif

#if( /* {public RequestSubscribeOrdersStateUpdateIfNeeded}. */ 1 )

      // yg? Should I rename this to {...Status...}? Maybe not.

      public: static void RequestSubscribeOrdersStateUpdateIfNeeded
         ( ::RApi::REngine & rEngine1,
           ::RApi::AccountInfo const & accountInfo1
         );

#endif
#if( /* {public SendOrder}. */ 1 )

      // Sends a new order request.
      // yg? Consider using the word "execute", such as {RequestExecuteOrder}?
      // yg? But that won't reflect the reality when sending a suspended/held order or even an "if-touched" order.
      // yg? Consider using the word "new order request" or "request new order".
      // yg? Consider to rename this to {SendNewOrder}, {SendNewOrderRequest}, {RequestNewOrder}.
      // yg? But then some other methods, such as strategy's {CreateAndSendEntryDeepOutOfMoneyOrders}
      // yg? would need to be renamed as well.

      public: static void SendOrder
         ( TSingleInstrumentOrder & order1
         );

#endif
#if( /* {public SendOrders}. */ 1 )

      //

      public:
         template
            < typename TSingleInstrumentsOrdersPointerIterator_
            >
         static void SendOrders
// TODO 2 yg? These should be reference iterators.
            ( TSingleInstrumentsOrdersPointerIterator_ orders1BeginIterator,
              TSingleInstrumentsOrdersPointerIterator_ orders1EndIterator
            );

#endif
#if( /* {public RequestModifyOrder}. */ 1 )

      // Only some order parameters can be modified and we will not necessarily check if the caller actually updated any
      // since the order was sent or previously modified. See code for details.
      // We will not roll back order parameters on failure.
      // yg? Another solution would be to not store any order parameters in the order object and instead maintain new order,
      // yg? modification, and cancellation request objects separately, possibly multiple objects of each kind.
      // If the {TSingleInstrumentOrderHelpers::CanModifyOrder} method would return {false} the behavior is officially undefined.

      public: static void RequestModifyOrder
         ( TSingleInstrumentOrder & order1
         );

#endif
#if( /* {public RequestModifyOrders}. */ 1 )

      //

      public:
         template
            < typename TSingleInstrumentsOrdersPointerIterator_
            >
         static void RequestModifyOrders
// TODO 2 yg? These should be reference iterators.
            ( TSingleInstrumentsOrdersPointerIterator_ orders1BeginIterator,
              TSingleInstrumentsOrdersPointerIterator_ orders1EndIterator
            );

#endif
#if( /* {public RequestCancelOrder}. */ 1 )

      // It's possible that we will have multiple pending cancellation requests,
      // especially after we request to cancel individual orders and then "any" orders.
      // But the brokerage will send only 1 new order, modification, or cancellation request at a time to the exchange
      // and will send back an {::RApi::OrderFailureReport} on any others.
      // Actually it often holds a cancellation request until a pending modification request completes and then sends it to the exchange.
      // If the {TSingleInstrumentOrderHelpers::CanCancelOrder} method would return {false} the behavior is officially undefined.

      public: static void RequestCancelOrder
         ( TSingleInstrumentOrder & order1
         );

#endif
#if( /* {public RequestCancelOrders}. */ 1 )

      //

      public:
         template
            < typename TSingleInstrumentsOrdersPointerIterator_
            >
         static void RequestCancelOrders
// TODO 2 yg? These should be reference iterators.
            ( TSingleInstrumentsOrdersPointerIterator_ orders1BeginIterator,
              TSingleInstrumentsOrdersPointerIterator_ orders1EndIterator
            );

#endif
#if( /* {public RequestCancelOrderIfCan}. */ 1 )

      // Assumption: we sent this order.
//TODO we don't need the above assumption? but we need it in RequestCancelOrderWhenCan
      // This method doesn't check if we are logged in -- the caller shall check that.

      public: static bool RequestCancelOrderIfCan
         ( TSingleInstrumentOrder & order1
         );

#endif
#if( /* {public RequestCancelOrderIfInternalCan}. */ 1 )

      // Assumption: we sent this order.
//TODO we don't need the above assumption? but we need it in RequestCancelOrderWhenCan
      // This method doesn't check if we are logged in -- the caller shall check that.

      public: static bool RequestCancelOrderIfInternalCan
         ( TSingleInstrumentOrder & order1
         );

#endif
#if( /* {public RequestCancelOrderIfInternalShallAndCan}. */ 1 )

      // Note that we don't have a method named {RequestCancelOrderIfShallWhenCan} because it would have the same effect.
      // {RequestCancelOrderIfCan} comment applies.
//TODO what comment? revisit

      public: static bool RequestCancelOrderIfInternalShallAndCan
         ( TSingleInstrumentOrder & order1
         );

#endif
#if( /* {public RequestCancelOrderWhenCan}. */ 1 )

      // {RequestCancelOrderIfCan} comment applies.
//TODO what comment? revisit
//TODO Assumption: we sent this order.

      public: static bool RequestCancelOrderWhenCan
         ( TSingleInstrumentOrder & order1
         );

#endif
#if( /* {public RequestCancelAnyOrders}. */ 1 )

      // Requests to cancel any suspended/held and working orders, regardless of whether our application or any other sent them.
      // In most cases call the other overload.

      public: static void RequestCancelAnyOrders
         ( ::RApi::REngine & rEngine1,
           ::RApi::AccountInfo const & accountInfo1
         );

#endif
#if( /* {public RequestCancelAnyOrders}. */ 1 )

      // This overload also updates all existing order objects if needed.
      // In most cases call this overload rather than the other one.
      // yg? This method might need more order collection parameters for non-single instrument orders.
      // yg? Some {TSingleInstrumentOrderHelpers::RegisterRequestCancelOrdersAsAnyIfCan} comments apply.

      public:
         //template
         //   < typename TSingleInstrumentsOrdersPointerIterator_
         //   >
         static void RequestCancelAnyOrders
            ( ::RApi::REngine & rEngine1,
              ::RApi::AccountInfo const & accountInfo1,
              //TSingleInstrumentsOrdersPointerIterator_ orders1BeginIterator,
              //TSingleInstrumentsOrdersPointerIterator_ orders1EndIterator
// TODO 2 yg? This map should contain order object references. Can we use {::std::reference_wrapper}?
              ::std::map< void const *, ::std::unique_ptr< TSingleInstrumentOrder > > & orders1
            );

#endif
   };
}
