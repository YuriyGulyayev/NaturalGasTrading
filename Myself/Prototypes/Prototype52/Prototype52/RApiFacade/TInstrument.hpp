#pragma once

#include "../Finance/TInstrumentBase.hpp"
#include "./TInstrumentConfiguration.hpp"

#include "../Common/SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace RApiFacade
{
   // yg? 
   class TREngineAdapter;

   // yg? There is no need to override the inherited {Prepare} method.
   // TODO 3 yg? Some members belong to the base class.

   class TInstrument :
      public ::Finance::TInstrumentBase< TREngineAdapter >
   {
#if( /* {private Symbol_}. */ 1 )

      //
      private: ::std::string Symbol_;

#endif
#if( /* {private ExchangeAbbreviation_}. */ 1 )

      // yg? Consider moving this above {Symbol_} and refactoring code and configuration everywhere.
      // yg? But {Symbol_} really should be moved to base class while {ExchangeAbbreviation_} doesn't necessarily belong there.
      private: ::std::string ExchangeAbbreviation_;

#endif
#if( /* {public QuantityIncrementMinLimit}. */ 1 )

      // The caller can update this field and must ensure thread safety. But currently we don't update it.
      // Assumption: this value is a multiple of 1.0 because in R|API quantity is an integer.
      // yg? Does this really belong here? Maybe this should be an instrument plus exchange or trade route parameter.
      // yg? This field is {public} to make it possible to update it afterwards.
      // yg? Should this field be {private}, coupled with a {Set...} method to update it?
      // yg? Consider moving the min increments to a {TQuantityAndPrice} instance. Bad idea as we might need more minimums,
      // yg? such as minimum order quantity, although that one might be an exchange or trade route parameter.
      // yg? Consider renaming this to something like {QuantityMoveAmountMinLimit}. Bad idea.
      // yg? Some of these comments apply to {PriceIncrementMinLimit} as well.
      public: double QuantityIncrementMinLimit;

#endif
#if( /* {public PriceIncrementMinLimit}. */ 1 )

      // yg? Some {QuantityIncrementMinLimit} comments apply.
      // yg? Consider renaming this to something like {PriceMoveAmountMinLimit}. Bad idea.
      public: double PriceIncrementMinLimit;

#endif
#if( /* {private TradeRouteName_}. */ 1 )

      // TODO 3 yg? This doesn't really belong here since an instrument can be traded via multiple routes -- to be revisited.
      // yg? Consider using the word "trading route", "order route", "order request route", or "order request sending route".
      // yg? Note that there is also the {sRoutingInstructions} field in some R|API classes but it's unclear what it means.
      private: ::std::string TradeRouteName_;

#endif

#if( /* {public} Instance default constructor. */ 1 )

      //

      public: explicit TInstrument();

#endif
#if( /* //{(private)} Instance copy constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* {public} Instance constructor. */ 1 )

      //

      public: explicit TInstrument
         ( TInstrumentConfiguration && configuration1
         );

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.
      // This probably doesn't need to be {virtual}.

#endif
#if( /* //{(private) operator =}. */ 1 )

      // Cannot be autogenerated.

#endif

#if( /* {public Initialize}. */ 1 )

      //

      public: void Initialize
         ( TInstrumentConfiguration && configuration1
         );

#endif
#if( /* {private DoInitialize}. */ 1 )

      //

      private: void DoInitialize
         ( TInstrumentConfiguration && configuration1
         );

#endif

#if( /* {public Symbol}. */ 1 )

      //

      public: ::std::string const & Symbol() const;

#endif
#if( /* {public ExchangeAbbreviation}. */ 1 )

      //

      public: ::std::string const & ExchangeAbbreviation() const;

#endif
#if( /* {public TradeRouteName}. */ 1 )

      //

      public: ::std::string const & TradeRouteName() const;

#endif
   };
}
