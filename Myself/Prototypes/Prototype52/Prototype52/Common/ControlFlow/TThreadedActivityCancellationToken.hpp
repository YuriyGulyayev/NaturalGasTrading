#pragma once

#include "../ObjectModel/TReferenceAtomicCounter.hpp"

#include "../SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Common
{
namespace ControlFlow
{
   // This class is patterned in part after the .NET's {System.Threading.CancellationToken} structure.
   // The reference counter is normally used to count threads that participate in the activity.
   // But prefer to avoid making this atomic increment and decrement every time a workitem is queued and executed on a thread pool thread.
   // TODO 3 yg? Reference counting would be more efficient if we maintain 2 reference counters: one atomic and another is not, and use one or another,
   // TODO 3 yg? depending on circumstances. Most reference counter increments are done within a locked scope and those don't have to be atomic,
   // TODO 3 yg? while a decrement at the end of a thread procedure after exiting the locked scope has to be atomic. Actually reference counter decrement
   // TODO 3 yg? can also be done within a locked scope but the method that waits for the reference counter to become 1 would need to lock and unlock
   // TODO 3 yg? the mutex at the end.
   // An instance of this class shall be created before and recycled after any object that can access it.
   // This class is thread safe and lock free.
   // An alternative would be to make it thread unsafe and require client code to implement a locking,
   // however that won't work in case the locking mechanism fails and would make it impossible to change state before entering a locked block.
   // yg? Although the methods are atomic they have no the word {Atomic} in their names (and neither does the class).
   // yg? We might need an equivalent of the {System.Threading.CancellationToken.Register} method.
   // yg? We might need a thread unsafe equivalent of this class for a single threaded, usually event driven activity,
   // yg? to be named similarly but without the {Threaded} word.
   // yg? Although a better option would be to add both thread safe and thread unsafe methods and eliminate the {Threaded} word.
   // yg? This class used to be named {TThreadedActivityStateToken} and I later simplified and renamed it.

   // TODO 3 yg? This is an old class that I should review and retrofit. Among other things,
   // TODO 3 yg? write down visible universe for the whole class and each method,
   // TODO 3 yg? separate any {if} and other similar blocks by line feeds, ensure source code lines are visible without scrolling.
   // TODO 3 yg? But as mentioned in other comments, this class really needs to be redesigned to be leaner and smarter.

   class TThreadedActivityCancellationToken :
      public ObjectModel::TReferenceAtomicCounter
   {
#if( /* {private Signaled_}. */ 1 )

      // This field is effectively volatile.
      // TODO 3 yg? This should be an integer which value is to be interpreted by the caller.
      // TODO 3 yg? The value can only be increased and never reduced.
      // TODO 3 yg? For example 1 can mean a graceful shutdown and 2 can mean an ASAP shutdown, possibly by throwing a
      // TODO 3 yg? {TOperationCancelledException}.
      private: bool Signaled_;

#endif

#if( /* {public} Instance default constructor. */ 1 )

      //

      public: explicit TThreadedActivityCancellationToken();

#endif
#if( /* //{(private)} Instance copy constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* //{(private) operator =}. */ 1 )

      // Cannot be autogenerated.

#endif

#if( /* {public NonVolatileSignalOnce}. */ 1 )

      // This method makes a non-volatile write to a member field.
      // The caller must cross a release memory barrier after calling this method, possibly by calling {release}.
      // yg? We don't need a volatile version of this method.

      public: void NonVolatileSignalOnce();

#endif
#if( /* {public VolatileGetSignaled}. */ 1 )

      // This method makes a volatile read of a member field.

      public: bool VolatileGetSignaled() const;

#endif
#if( /* {public Signaled}. */ 1 )

      // This method makes a non-volatile read of a member field.
      // yg? Consider renaming this method to {NonVolatileGetSignaled}.

      public: bool Signaled() const;

#endif
#if( /* {public NonVolatileValidateNotSignaled}. */ 1 )

      // If the object is signaled: throws a {TOperationCancelledException}.
      // The caller must cross an acquire memory barrier before calling this method.
      // yg? We might need a volatile version of this method but it would be more expensive on some platforms.
            
      public: void NonVolatileValidateNotSignaled() const;

#endif
#if( /* {public NonVolatileSignalOnceAndWaitUntilReleased}. */ 1 )

      // The waiting crosses a full memory barrier on each loop, which makes a non-volatile signaling appropriate.
      // yg? But if the reference counter is already released this will cross only an acquire memory barrier.
      // Anyway, this method promises to cross only an acquire memory barrier, which is sufficient to make it safe to recycle the whole object model afterwards.

      public: void NonVolatileSignalOnceAndWaitUntilReleased
         ( int referenceCounter1ValueMaxLimit
         );

#endif
   };
}
}
