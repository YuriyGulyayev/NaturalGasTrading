#pragma once

#include "./TSocketNextDynamicPortNumberAdvancerConfiguration.hpp"

#include "../SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Common
{
namespace Networking
{
   // This class allows to advance the counter the system uses to dynamically generate a port number when binding a socket.
   // {TSocket_} should normally be {::Poco::Net::StreamSocket} or {::Poco::Net::DatagramSocket}.
   // It matters which one is used as the UDP and TCP protocols use separate counters.
   // See the config file for more info.
   // See
   // "X:\MyDocuments\Business\Projects\Active\Forteco\NaturalGasTrading\SourceCode\Myself\Prototypes\PocoTest1\PocoTest1\PocoTest1.cpp",
   // {Test11}.
   // yg? To be tested on Linux.
   // yg? Consider using the word "atomic" in this class or its methods names.

   template
      < typename TSocket_
      >
   class TSocketNextDynamicPortNumberAdvancer
   {
#if( /* {private NumberSocketNextDynamicPortNumberIncrements_}. */ 1 )

      //
      private: int NumberSocketNextDynamicPortNumberIncrements_;

#endif
#if( /* {private Socket_}. */ 1 )

      // A socket object is created and memory for {Socket_.impl()} is allocated in advance.
      private: TSocket_ mutable Socket_;

#endif

#if( /* {public} Instance default constructor. */ 1 )

      //

      public: explicit TSocketNextDynamicPortNumberAdvancer();

#endif
#if( /* {private} Instance copy constructor. */ 1 )

      //

      private: explicit TSocketNextDynamicPortNumberAdvancer
         ( TSocketNextDynamicPortNumberAdvancer const & source
         );

#endif
#if( /* {public} Instance constructor. */ 1 )

      //

      public: explicit TSocketNextDynamicPortNumberAdvancer
         ( TSocketNextDynamicPortNumberAdvancerConfiguration && configuration1
         );

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* {private operator =}. */ 1 )

      //

      private: TSocketNextDynamicPortNumberAdvancer & operator =
         ( TSocketNextDynamicPortNumberAdvancer const & source
         );

#endif

#if( /* {public Initialize}. */ 1 )

      //

      public: void Initialize
         ( TSocketNextDynamicPortNumberAdvancerConfiguration && configuration1
         );

#endif
#if( /* {private DoInitialize}. */ 1 )

      //

      private: void DoInitialize
         ( TSocketNextDynamicPortNumberAdvancerConfiguration && configuration1
         );

#endif
#if( /* {public Run}. */ 1 )

      //

      public: void Run
         ( //int numberLoops
         ) const;

#endif
#if( /* {public RunUntilNextMillisecond}. */ 1 )

      // yg? This desn't guarantee a specific number of increments and on the other hand can potentially result in too many increments
      // yg? and waste of CPU power. One way to fix this is to store the number of remaining increments in a member field
      // yg? and when it becomes 0 or if it's already 0 just break the loop and sleep until the next millisecond. There will need to be
      // yg? a separate method to re-generate the random number. If I get this done I'll also need to refactor the caller to not check that
      // yg? {NumberSocketNextDynamicPortNumberIncrements()} is positive.
      // TODO 3 yg? Revisit this when we are about to run on a 100 GHz processor.

      public: void RunUntilNextMillisecond() const;

#endif

#if( /* {public NumberSocketNextDynamicPortNumberIncrements}. */ 1 )

      //

      public: int NumberSocketNextDynamicPortNumberIncrements() const;

#endif
   };
}
}
