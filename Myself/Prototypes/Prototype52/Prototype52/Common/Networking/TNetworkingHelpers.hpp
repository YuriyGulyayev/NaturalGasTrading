#pragma once

#include "../DataStructures/TUnionPair.hpp"

#include "../SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Common
{
namespace Networking
{
   //

   class TNetworkingHelpers abstract sealed
   {
#if( /* {public SocketReceiveTimeoutTimeSpanMillisecondsAdjustment}. */ 1 )

      // We need this to adjust for Windows adding 500 ms to socket receive timeout.
      public: static int const SocketReceiveTimeoutTimeSpanMillisecondsAdjustment =
   #if( defined( _MSC_VER ) )
         ( - 500 );
   #else
         0;
   #endif

#endif

#if( /* {public WildcardIPAddress}. */ 1 )

      // We can use this constant field to efficiently copy-construct a {::Poco::Net::IPAddress} instance.
      // TODO 3 yg? Some day I'll need to rename this to {WildcardIPv4Address}.
      // yg? Consider renaming this to {IPWildcardAddress}.
      public: static ::Poco::Net::IPAddress const WildcardIPAddress;

#endif
#if( /* {public WildcardIPSocketAddress}. */ 1 )

      // We can use this constant field to efficiently copy-construct a {::Poco::Net::SocketAddress} instance.
      // TODO 3 yg? Some day I'll need to rename this to {WildcardIPv4SocketAddress}.
      // yg? Consider renaming this to {IPWildcardSocketAddress}, {IPSocketWildcardAddress}, {SocketIPWildcardAddress}, or something of that sort.
      public: static ::Poco::Net::SocketAddress const WildcardIPSocketAddress;

#endif

#if( /* {private SocketHandleToWaitOn_}. */ defined( _MSC_VER ) )

      // yg? Consider using {::poco_socket_t} instead of {::SOCKET}. It might be a bad idea to do so on Windows.
      // TODO 3 yg? Use {::NtDelayExecution}.
      private: static DataStructures::TUnionPair< ::SOCKET, void * > SocketHandleToWaitOn_;

      static_assert( sizeof( SocketHandleToWaitOn_.Value1 ) == sizeof( SocketHandleToWaitOn_.Value2 ), "" );

#endif

#if( /* //{(private)} Instance default constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* //{(private)} Instance copy constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* //{(private) operator =}. */ 1 )

      // Cannot be autogenerated.

#endif

#if( /* {public SleepMicrosecondsWithSelect}. */ defined( _MSC_VER ) )

      // Calls the {::select} function to sleep.
      // Does nothing when {timeSpanMicroseconds <= 0}.
      // TODO 2 yg? Remember to call {DoSleepMicrosecondsWithSelect} instead of {SleepMicrosecondsWithSelect} when appropriate.
      // The caller must call {::Poco::Net::initializeNetwork}.
      // To ensure accurate result on Windows, the caller must call {::timeBeginPeriod} or {::timeSetEvent}.
      //
      // yg? On Windows, we need this method because the {::Sleep} function sleeps for at least 2 multimedia timer ticks
      // yg? and we need the possibility to sleep until after the next tick.
      // yg?? On Windows, this method seems to work when called on multiple threads but that could be accidential.
      // yg? On Windows, we should instead use a waitable timer. But we would need to ensure that only 1 thread can use the same waitable timer
      // yg? and when a thread is sleeping any other one would need to create another waitable timer.
      // yg? A problem with a waitable timer is that a thread would have to make 2 system calls per sleep: to schedule a timer tick and then wait on the timer.
      // TODO 3 yg? Use {::NtDelayExecution}.
      //
      // yg? On Linux, we don't use this method.
      // yg? This method will likely work on Linux but was never tested. When testing make sure it works when called on multiple threads.
      // yg? People wrote on forums that on Linux it was OK to pass all {nullptr}s to the {::select} function, so we would not need {SocketHandleToWaitOn_}.
      // yg? On Linux, the sleeping can be interrupted by a signal, so this implementation would be unreliable.
      // yg? Consider returning a flag indicating if the sleeping was interrupted, but that would be an unnecessary overhead.
      //
      // yg? Does this method belong to this class? Maybe we need some socket related helpers.

      public: static void SleepMicrosecondsWithSelect
         ( long timeSpanMicroseconds
         );

#endif
#if( /* {public DoSleepMicrosecondsWithSelect}. */ defined( _MSC_VER ) )

      // Assumption: {timeSpanMicroseconds > 0}.
      // TODO 2 yg? Remember to call {DoSleepMicrosecondsWithSelect} instead of {SleepMicrosecondsWithSelect} when appropriate.
      // TODO 3 yg? Use {::NtDelayExecution}.

      public: static void DoSleepMicrosecondsWithSelect
         ( long timeSpanMicroseconds
         );

#endif

#if( /* {public AddSocketAddressesFromUrls}. */ 1 )

      // Any existing items in {socketAddresses1} will stay in there. New items will be appended.
      // {TUrlAsStringContainer1CollectionIterator_} should be a {const} iterator.
      // TODO 3 yg? Specify {socketAddresses1} data type as a template parameter.
      // TODO 3 yg? This solution is ugly. Can we use {::boost::make_transform_iterator}?
      // TODO 3 yg? Can we do something like this?:
      // TODO 3 yg? template
      // TODO 3 yg?    < typename TUrlAsStringContainer1CollectionIterator_,
      // TODO 3 yg?       ::std::string typename ::std::remove_reference< decltype( * ( * static_cast< TUrlAsStringContainer1CollectionIterator_ * >( nullptr ) ) ) >::type::*urlAsStringContainer1UrlAsStringPointerToMember
      // TODO 3 yg?    >
      // TODO 3 yg? Actually, the line containing {::std::string typename ...} is apparently mistyped.
      // yg? Does this method belong to this class? Maybe we need some socket related helpers.
      // yg? Consider renaming this to {Append...}.
      // TODO 3 yg? Do we use this method? Comment it out.

      public:
         template
            < typename TUrlAsStringContainer_,
               ::std::string TUrlAsStringContainer_::*urlAsStringContainer1UrlAsStringPointerToMember,
               typename TUrlAsStringContainer1CollectionIterator_
            >
         static void AddSocketAddressesFromUrls
            ( ::std::vector< ::Poco::Net::SocketAddress > & socketAddresses1,
              TUrlAsStringContainer1CollectionIterator_ urlAsStringContainers1BeginIterator1,
              TUrlAsStringContainer1CollectionIterator_ urlAsStringContainers1EndIterator1
            );


      // yg? Old version. To be revisited.
      //
      //// Any existing items in {socketAddresses1} will stay in there. New items will be appended.
      //// TODO 3 yg? This solution is ugly. Can we use {::boost::make_transform_iterator}?
      //// yg? Consider replacing {numberUrlAsStringContainers1} with an end iterator. But the iterators would have to implement subtraction operator
      //// yg? to subtract them from each other.
      //// yg? Does this method belong to this class? Maybe we need some socket related helpers.
      //
      //public:
      //   template
      //      < //typename TUrlAsStringIterator1 <<<this should end with a {_}.
      //         typename TUrlAsStringContainerIterator1, <<<this should end with a {_}.
      //         typename TPointerToUrlAsStringContainerUrlAsStringMember1 <<<this should end with a {_}.
      //      >
      //   static void AddSocketAddressesFromUrls
      //      ( ::std::vector< ::Poco::Net::SocketAddress > & socketAddresses1,
      //        //TUrlAsStringIterator1 urlAsStringIterator1,
      //        TUrlAsStringContainerIterator1 urlAsStringContainerIterator1,
      //        int numberUrlAsStringContainers1,
      //        TPointerToUrlAsStringContainerUrlAsStringMember1 pointerToUrlAsStringContainerUrlAsStringMember1
      //      );

#endif
#if( /* {public TrySetSocketKeepAliveMode}. */ 1 )

      // TODO 3 yg? Do we use this method? Comment it out.

      public: static bool TrySetSocketKeepAliveMode
         ( ::Poco::Net::Socket & socket,
           bool keepAliveEnabled
         );

#endif
#if( /* {public SetSocketKeepAliveMode}. */ 1 )

      // On error throws an {ErrorHandling::TRegularErrorException}.
      // yg? We might need a {Try...} counterpart that doesn't throw exceptions.
      // TODO 3 yg? Do we use this method? Comment it out.
      //
      // {keepAliveTimeoutTimeSpanMilliseconds} specifies the timeout with no activity until the first keep-alive packet is sent.
      // {keepAliveIntervalMilliseconds} specifies the interval between when successive keep-alive packets are sent if no acknowledgement is received.
      // On Windows, the number of keep-alive probes (data retransmissions) is set to 10.
      // The documentation doesn't say how long is the timeout to receive an acknowledgement but testing revealed that it appears to be equal
      // {keepAliveIntervalMilliseconds} provided the later is not "too small". The "too small" value is 10, meaning that where we use {keepAliveIntervalMilliseconds}
      // in the following formula it's actually implied to be { max( keepAliveIntervalMilliseconds, 11 ) }. This number might have been different
      // if the number of keep-alive probes was different from 10.
      // The longest it can take to detect a connection loss would be if the connection breaks within {keepAliveTimeoutTimeSpanMilliseconds}
      // after it was established, and that would be:
      // { keepAliveTimeoutTimeSpanMilliseconds + ( keepAliveIntervalMilliseconds * ( 10 - 1 ) ) + keepAliveIntervalMilliseconds } milliseconds.
      // The minimum time to detect a connection loss would be less by {keepAliveTimeoutTimeSpanMilliseconds}.
      // {keepAliveIntervalMilliseconds} should be at least twice the ping time.

      public: static void SetSocketKeepAliveMode
         ( ::poco_socket_t socketHandle,
           bool keepAliveEnabled,
           int keepAliveTimeoutTimeSpanMilliseconds,
           int keepAliveIntervalMilliseconds
         );

#endif
#if( /* {public SelectAnySocketsReadyForReadingHandle}. */ 1 )

      // This method throws an {ErrorHandling::TCriticalErrorException} if {::select} returns a negative value.
      // We don't assume that the {socketsHandle} collection is not empty
      // but if it's really not the case the {::select} function will fail on Windows and we will throw an exception.
      // yg? This design serves only our immediate needs.
      // TODO 3 yg? Performance improvement idea: maintain a pre-populated {::fd_set} and quickly duplicate it and {::select} the copy.
      // TODO 3 yg? We would need to remove an item from it when removing a {socketsHandle} item
      // TODO 3 yg? but it might be easier and not too inefficient to repopulate it after removing a {socketsHandle} item.
      // TODO 3 yg? We need an {std} algorithm function that removes an item from an array/collection and compacts remaining items.
      // yg? Does this method belong to this class? Maybe we need some socket related helpers.
      // yg? Do we really need the word "any" in this method name?
      // yg? Does it make sense to rename {TSocketHandleMap_} to {TSocketsHandleMap_}? Maybe not.

      public:
         template
            < typename TSocketHandleMap_
            >
         static int SelectAnySocketsReadyForReadingHandle
            ( TSocketHandleMap_ const & socketsHandle,
              ::fd_set & socketsReadyForReadingHandle,
              long timeoutTimeSpanMicroseconds
            );

#endif
#if( /* {public SendBytesIntoSocket}. */ 1 )

      // This method throws an {ErrorHandling::TRegularErrorException} if the number of bytes sent differs from {bytesLength}.
      // It doesn't tell the caller how many bytes have actually been sent, if any. If the caller needs to know that it must call
      // {socket.sendBytes} directly.
      // This method is intended to be used in the scenarios when the non-sending of all bytes is considered an unrecoverable error.
      // Note that some POCO sockets guarantee to send all bytes under certain conditions,
      // so in those cases it would be incorrect to use this method.

      public: static void SendBytesIntoSocket
         ( ::Poco::Net::Socket & socket,
           char const * bytes,
           int bytesLength,
           int flags
         );

#endif
   };
}
}
