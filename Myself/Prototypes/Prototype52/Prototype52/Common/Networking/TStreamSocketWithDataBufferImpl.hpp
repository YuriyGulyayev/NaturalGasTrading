#pragma once

#include "../DataStructures/TDataBuffer.hpp"

#include "../SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Common
{
namespace Networking
{
   // yg? Consider making this a template with base class being template parameter. Bad idea?
   // yg? Consider declaring {TStreamSocketWithDataBuffer} a {friend} of this class.
   // yg? This class doesn't currently use rvalue references. It doesn't have a {Swap} method either.

   class TStreamSocketWithDataBufferImpl :
      public ::Poco::Net::StreamSocketImpl
   {
#if( /* {public DataBuffer}. */ 1 )

      // We don't have a constructor that reserves a capacity/length for {DataBuffer}, which is probably better.
      // I feel that this field should be {public}.
      // yg? Should there be the word "respose" in this field name?
      // yg? Maybe not to leave the door open to store the data to send here.
      // yg? But if so I would probably have to rename the whole class.
      public: DataStructures::TDataBuffer DataBuffer;

#endif
#if( /* {public DataBufferCapacityMaxLimit}. */ 1 )

      // The caller shall assign a value to this field.
      // Assumption: {DataBufferCapacityMaxLimit <= DataBuffer.max_size()}.
      // I feel that this field should be {public}.
      public: DataStructures::TDataBuffer::size_type DataBufferCapacityMaxLimit;

#endif

#if( /* {public} Instance default constructor. */ 1 )

      //

      public: explicit TStreamSocketWithDataBufferImpl();

#endif
#if( /* //{(private)} Instance copy constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* {public} Instance constructor. */ 1 )

      //

      public: explicit TStreamSocketWithDataBufferImpl
         ( ::Poco::Net::IPAddress::Family ipAddressFamilyCode
         );

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.
      // {virtual}.

#endif
#if( /* //{(private) operator =}. */ 1 )

      // Cannot be autogenerated.

#endif

#if( /* {public ReceiveBytesIntoDataBuffer}. */ 1 )

      // Reads data from the socket and appends it to {DataBuffer}.
      // In blocking mode this method blocks until any data is available to read, the counterparty closes the connection,
      // or receive timeout expires. If receive timeout expires an exception will be thrown.
      // In non-blocking mode if no data is immediately available to read an exception will be thrown.
      // This method will resize {DataBuffer} as needed but it minimizes memory use at the expense of speed,
      // therefore to improve performance allocate a sufficient length for {DataBuffer} in advance.
      // The buffer capacity will not be increased if any is still available, which can result in fewer bytes read than available.
      // In fact, the documentation says that the {available} and {receiveBytes} methods can also report/read
      // fewer bytes than actually available but it's probably unlikely to happen.
      // Returns the number of bytes read.

      public: int ReceiveBytesIntoDataBuffer
         ( int flags1
         );

#endif
#if( /* //{public ReceiveAllBytesIntoDataBuffer}. */ 1 )

      //// This method is intended to be called in blocking mode only. Otherwise call {ReceiveAnyBytesIntoDataBufferUntilWouldBlock}.
      //// Even if an exception is thrown some data can still be received, which will be indicated by {DataBuffer.DataLength}.
//>>> Should this return the number of bytes read on the last iteration? This would allow the caller to react on 0 bytes read.
      //
      //public: void ReceiveAllBytesIntoDataBuffer
      //   ( int flags1
      //   );

#endif
#if( /* //{public ReceiveAnyBytesIntoDataBuffer}. */ 1 )

      //// This method is intended to be called in blocking mode only. Otherwise call {ReceiveAnyBytesIntoDataBufferUntilWouldBlock}.
      //// Even if an exception is thrown some data can still be received, which will be indicated by {DataBuffer.DataLength}.
//>>> Should this return the number of bytes read on the last iteration? This would allow the caller to react on 0 bytes read.
      //
      //public: void ReceiveAnyBytesIntoDataBuffer
      //   ( int flags1
      //   );

#endif
#if( /* //{public ReceiveAnyBytesIntoDataBufferUntilWouldBlock}. */ 1 )

      // yg? I commented this out but we might need a method that calls {ReceiveBytesIntoDataBuffer} once and swallows
      // yg? a {::Poco::TimeoutException}. It will need to distinguish between 0 bytes read and no bytes read.

      //// Calls the {ReceiveBytesIntoDataBuffer} method within an infinite loop until a "would block" situation or the receive timeout expires.
      //// This method is intended to be called in non-blocking mode only.
      //// Otherwise it will either never return or the configured receive timeout will be restarting from 0 on each loop.
      //// Even if an exception is thrown some data can still be received, which will be indicated by {DataBuffer.DataLength}.
//>>> Should this return the number of bytes read on the last iteration? This would allow the caller to react on 0 bytes read.
      //
      //public: void ReceiveAnyBytesIntoDataBufferUntilWouldBlock
      //   ( int flags1
      //   );

#endif
   };
}
}
