#pragma once

//#include "./.hpp"

#include "../SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Common
{
namespace ObjectModel
{
   // This class exposes the same interface as the {::Poco::RefCountedObject} class but it's more efficient.
   // This class only counts references but doesn't {delete} itself.
   // The counting is atomic.
   // This class can be used as a base class or as is.
   // This class doesn't handle reference counter overflow or underflow.
   // yg? Consider making this class a template on the reference counter type and specializations for {int}, {::Poco::Int32},
   // yg? {::Poco::Int64}.
   // yg? Although the methods are atomic they have no word {Atomic} in their names (the class has).
   // yg? We might need a similar class that also {delete}s itsef. One way to name it would be
   // yg? {TReferenceAtomicCountingSelfRecyclingObject}.
   // yg? Do we really need this class? We can simply use an integer instead. But we can use this interface with some POCO methods.
   // yg? Consider renaming this class to {TReferencesAtomicCounter}. Bad idea. I don't do that with the word "counter".

   class TReferenceAtomicCounter
   {
#if( /* {private Value_}. */ 1 )

      // This field is effectively volatile.
      // yg? This field is declared {mutable}, as it is in the {::Poco::RefCountedObject} class,
      // yg? but it's incorrect as its value is a part of this class visible state.
      private: mutable int Value_;

#endif

#if( /* {public} Instance default constructor. */ 1 )

      //

      public: explicit TReferenceAtomicCounter();

#endif
#if( /* {private} Instance copy constructor. */ 1 )

      //

      private: explicit TReferenceAtomicCounter
         ( TReferenceAtomicCounter const & source
         );

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.
      // yg? The destructor is not virtual.

#endif
#if( /* {private operator =}. */ 1 )

      //

      private: TReferenceAtomicCounter & operator =
         ( TReferenceAtomicCounter const & source
         );

#endif

#if( /* {public ReferenceCounterValue}. */ 1 )

      // This method makes a non-volatile read of a member field.

      public: int ReferenceCounterValue() const;

#endif
#if( /* {public referenceCount}. */ 1 )

      // This method makes a volatile read of a member field.
      // yg? This method should be named {VolatileGetReferenceCounter} or {VolatileGetReferenceCounterValue}.

      public: int referenceCount() const;

#endif
#if( /* {public duplicate}. */ 1 )

      // yg? This method doesn't cross a memory barrier, which is probably appropriate in most cases.
      // yg? Returns the new value of the reference counter, which can introduce an inefficiency on some platforms.
      // yg? We might need a method that crosses a memory barrier.
      // yg? This method should be named {IncrementReferenceCounter}, {IncrementAndGetReferenceCounter}, {IncrementReferenceCounterValue}, or {Increment}.

      public: int duplicate() const;

#endif
#if( /* {public release}. */ 1 )

      // yg? This method crosses a release memory barrier, which is probably appropriate in most cases.
      // yg? Returns the new value of the reference counter, which can introduce an inefficiency on some platforms.
      // yg? We might need a method that doesn't cross a memory barrier.
      // yg? Just like {duplicate}, this method should be named differently.

      public: int release() const;

#endif
   };
}
}
