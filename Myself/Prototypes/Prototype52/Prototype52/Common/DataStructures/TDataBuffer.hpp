#pragma once

//#include "./.hpp"

#include "../SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Common
{
namespace DataStructures
{
   // The {::std::string} class is inefficient as it initializes the memory it allocates. It also initializes the chars added via resizing
   // even if a sufficient capacity was allocated in advance.
   // So this class is designed to avoid expensive resizings.
   // Data buffer capacity is defined as {length()}. And there is also {capacity()}, which is unrelated but introduces a confusion.
   // This class and those that use it should prefer using the word "capacity" instead of "length".
   // {length()} and {capacity()} are usually equal, however {capacity()} can be longer due to the underlying implementation.
   // So in rare cases the caller can avoid the expense of a memory allocation by resizing the string to its capacity
   // but our principle is to never attempt to do that -- to keep it simple.
   // TODO 3 yg? We need a constructor that accepts capacity (string length), {char} pointer, number of chars. Plus possibly an overload
   // TODO 3 yg? that accepts a string instead of the last two. And overloads for the string as an lvalue and an rvalue reference.
   // TODO 3 yg? Review the class if any other similar overloads needed.
   // TODO 3 yg? It's to be used in {::Prototype52::TPetroleumStatusReportDownloader::GetResponseContentForWarmUp}.
   // yg? Consider renaming this class to {TStringBasedDataBuffer}.

   class TDataBuffer :
      public ::std::string
   {
#if( /* {public DataLength}. */ 1 )

      // The caller is responsible for updating this field and making sure it doesn't exceed string length.
      public: size_type DataLength;

#endif

#if( /* {public} Instance default constructor. */ 1 )

      //

      public: explicit TDataBuffer();

#endif
#if( /* {public} Instance copy constructor. */ 1 )

      //

      public: explicit TDataBuffer
         ( TDataBuffer const & source
         );

#endif
#if( /* {public} Instance move constructor. */ 1 )

      //

      public: TDataBuffer
         ( TDataBuffer && source
         );

#endif
#if( /* {public} Instance constructor. */ 1 )

      // This constructor sets {DataLength = 0U}.

      public: explicit TDataBuffer
         ( size_type stringLength
         );

#endif
#if( /* {public} Instance constructor. */ 1 )

      // This constructor sets {DataLength = data1Length}.
      // yg? It might be better to swap the parameters but I preserved the base class constructor parameter order.

      public: explicit TDataBuffer
         ( size_type data1Length,
           value_type char1
         );

#endif
#if( /* {public} Instance constructor. */ 1 )

      // This constructor sets {DataLength = data1Length}.

      public: explicit TDataBuffer
         ( const_pointer data1,
           size_type data1Length
         );

#endif
#if( /* {public} Instance constructor. */ 1 )

      // This constructor sets {DataLength = data1.length()}.

      public: explicit TDataBuffer
         ( ::std::string const & data1
         );

#endif
#if( /* {public} Instance constructor. */ 1 )

      // This constructor sets {DataLength = data1.length()}.

      public: explicit TDataBuffer
         ( ::std::string && data1
         );

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.
      // This probably doesn't need to be {virtual}.

#endif
#if( /* {public operator =}. */ 1 )

      //

      public: TDataBuffer & operator =
         ( TDataBuffer const & source
         );

#endif
#if( /* {public operator =}. */ 1 )

      //

      public: TDataBuffer & operator =
         ( TDataBuffer && source
         );

#endif

#if( /* {public AllocateAdditionalCapacityIfNeeded}. */ 1 )

      // Tries to ensure that data buffer available capacity is at least {additionalCapacity}. In other words,
      // {length() - DataLength >= additionalCapacity}.
      // Ensures that available capacity is at least {additionalCapacityMinLimit} and total capacity is at most {capacityMaxLimit}
      // or else throws an exception.
      // If {length() > capacityMaxLimit} the value of {length()} is used instead of {capacityMaxLimit}.
      // Assumption: {additionalCapacity >= additionalCapacityMinLimit}.
      // Assumption: {capacityMaxLimit <= max_size()}.
      // yg? Consider using the word "available" instead of "additional" but the phrase "allocate available capacity" would be ugly.

      public: void AllocateAdditionalCapacityIfNeeded
         ( size_type additionalCapacity,
           size_type additionalCapacityMinLimit,
           size_type capacityMaxLimit
         );

#endif

#if( /* {public Assign}. */ 1 )

      //

      public: void Assign
         ( TDataBuffer const & source
         );

#endif
#if( /* {public Assign}. */ 1 )

      // yg? Should this be named {Move}?

      public: void Assign
         ( TDataBuffer && source
         );

#endif
#if( /* {public Assign}. */ 1 )

      //

      public: void Assign
         ( const_pointer data1,
           size_type data1Length
         );

#endif
#if( /* {public Append}. */ 1 )

      //

      public: void Append
         ( const_pointer data1,
           size_type data1Length
         );

#endif

#if( /* {public LessThan}. */ 1 )

      //

      public: static bool LessThan
         ( TDataBuffer const & instance1,
           TDataBuffer const & instance2
         );

#endif
   };

#if( /* {public operator <}. */ 1 )

   //

   bool operator <
      ( TDataBuffer const & instance1,
        TDataBuffer const & instance2
      );

#endif
}
}
