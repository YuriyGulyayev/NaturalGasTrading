#pragma once

//#include "./.hpp"

#include "../SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Common
{
namespace ErrorHandling
{
   //

   class TErrorHandlingHelpers abstract sealed
   {
#if( /* //{(private)} Instance default constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* //{(private)} Instance copy constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* //{(private) operator =}. */ 1 )

      // Cannot be autogenerated.

#endif

#if( /* {public AtomicLastChanceHandleException}. */ 1 )

      // --not any more-- The caller must call {::Poco::Net::initializeNetwork} to make it possible to sleep with {::select}.
      // yg? Consider doing nothing on a reentry. We would need a thread-static flag.
      // yg? Consider renaming this method to {AtomicLastChanceTryHandleException} or {AtomicTryLastChanceHandleException}.

      public: static void AtomicLastChanceHandleException
         ( ::Poco::Exception const & exception1
         );

#endif
#if( /* {public AtomicLastChanceHandleException}. */ 1 )

      // yg? See the 1st overload comment.

      public: static void AtomicLastChanceHandleException
         ( ::std::exception const & exception1
         );

#endif
#if( /* {public AtomicLastChanceHandleException}. */ 1 )

      // yg? See the 1st overload comment.

      public: static void AtomicLastChanceHandleException();

#endif
   };
}
}
