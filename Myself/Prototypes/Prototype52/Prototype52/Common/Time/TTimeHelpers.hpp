#pragma once

//#include "./.hpp"

#include "../SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Common
{
namespace Time
{
   //

   class TTimeHelpers abstract sealed
   {
#if( /* //{public NumberDaysInJanuary}. */ 1 )

      //// yg? This should be provided by a standard API.
      //public: static int const NumberDaysInJanuary = 31;

#endif

#if( /* {public MinDateTime}. */ 1 )

      // We can use this constant field to efficiently copy-construct a {::Poco::DateTime} instance.
      public: static ::Poco::DateTime const MinDateTime;

#endif
#if( /* {public MinTimeStamp}. */ 1 )

      // We can use this constant field to efficiently copy-construct a {::Poco::Timestamp} instance.
      public: static ::Poco::Timestamp const MinTimeStamp;

#endif

#if( /* //{(private)} Instance default constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* //{(private)} Instance copy constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* //{(private) operator =}. */ 1 )

      // Cannot be autogenerated.

#endif

#if( /* {public GetCpuTimeStampCounter}. */ 1 )

      // yg? This doesn't always count CPU clock cycles. So maybe use the word "CPU time" or "CPU clock time".
      // yg? Although it probably counts those as if the CPU (or is it CPU clock?) ran at its maximum refresh rate.

      public: static ::Poco::Int64 GetCpuTimeStampCounter();
      //public: static ::Poco::Int64 GetCpuClockCycleCounter();

#endif

#if( /* {public AtomicSetMultimediaTimerResolutionMilliseconds}. */ 1 )

      // Assumption: {multimediaTimerResolutionMilliseconds1 >= 0}.
      // The value of 0 will probably not work but it's reserved to denote the maximum possible resolution.
      // yg? The timer will be reprogrammed only after its next tick, which can potentially cause incorrect behavior.
      // yg? Consider using the word "thread time slice".
      // TODO 3 yg? Use {::NtSetTimerResolution}.

      public: static void AtomicSetMultimediaTimerResolutionMilliseconds
         ( int multimediaTimerResolutionMilliseconds1
         );

#endif
#if( /* {public AtomicRestoreMultimediaTimerResolutionMilliseconds}. */ 1 )

      // yg? {AtomicSetMultimediaTimerResolutionMilliseconds} comment applies.

      public: static void AtomicRestoreMultimediaTimerResolutionMilliseconds
         ( int multimediaTimerResolutionMilliseconds1
         );

#endif
#if( /* {public GetMultimediaCurrentTimeMilliseconds}. */ 1 )

      // To ensure accurate result on Windows, the caller must call {::timeBeginPeriod} or {::timeSetEvent}.
      // yg? The timestamp size is platform dependent. Currently the method returns an {int}.
      // yg? Consider returning a {::Poco::Int32} and/or renaming the method to {GetMultimediaCurrentTimeMillisecondsAsInt32}.
      // yg? Consider adding another method to return a {::Poco::Int64}; it would need to handle the overflow and ensure that the result will never overflow.
      // yg? Should this method be named {Atomic...}? It would make sense if return value size is bigger than processor word but this sort of reasoning is a stretch.
      // TODO 3 yg? Use {::QueryUnbiasedInterruptTime}.

      public: static int GetMultimediaCurrentTimeMilliseconds();

#endif
   };
}
}
