#pragma once

//#include "./.hpp"

#include "../SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Common
{
namespace Configuration
{
   //

   class TConfigurationHelpers abstract sealed
   {
#if( /* //{(private)} Instance default constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* //{(private)} Instance copy constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* //{(private) operator =}. */ 1 )

      // Cannot be autogenerated.

#endif

#if( /* //{public ExtractConfiguration}. */ 1 )

   //   // This method does not validate the configuration.
   //   // yg? This method can be implemented more generically.
   //   // yg? Ideas:
   //   // yg? 1. Methods to extract configuration fields, such as {getInt} should be passed as template parameters.
   //   // yg? 2. This whole method can be a specializable temlate.
   //
      //public:
      //   template
      //      < typename TString_
      //      >
      //   static void ExtractConfiguration
      //      ( ::std::pair< TString_, int > & configuration1,
      //        ::Poco::Util::AbstractConfiguration const & abstractConfiguration1,
      //        ::std::string const & value1Name,
      //        ::std::string const & value2Name
      //      );

#endif
#if( /* {public ExtractConfigurations}. */ 1 )

      // This method does not validate the configuration.
      // yg? This method can be implemented more generically.
      // TODO 3 yg? Do we use this method? Comment it out.

      public:
         template
            < typename TString_
            >
         static void ExtractConfigurations
            ( ::std::map< TString_, int > & configurations1,
              ::Poco::Util::AbstractConfiguration const & abstractConfiguration1
            );

#endif
   };
}
}
