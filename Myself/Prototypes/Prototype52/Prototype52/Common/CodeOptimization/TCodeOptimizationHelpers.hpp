#pragma once

//#include "./.hpp"

#include "../SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Common
{
namespace CodeOptimization
{
   // yg? Consider merging this class with {Threading::TMemoryAtomicOperationsHelpers} or at least coordinate refactoring of the classes.
   // yg? I don't like it that the names of this class and its namespace don't specify which code we refer to. Should we use the word
   // yg? "binary code"?

   class TCodeOptimizationHelpers abstract sealed
   {
#if( /* //{(private)} Instance default constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* //{(private)} Instance copy constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* //{(private) operator =}. */ 1 )

      // Cannot be autogenerated.

#endif

#if( /* //{public MemoryReadBarrier}. */ 1 )

      //// This method only suppresses code optimization by the compiler and does not suppresses one by hardware.

      //public: static void MemoryReadBarrier();

#endif
#if( /* //{public MemoryWriteBarrier}. */ 1 )

      //// This method only suppresses code optimization by the compiler and does not suppresses one by hardware.

      //public: static void MemoryWriteBarrier();

#endif
#if( /* //{public MemoryReadWriteBarrier}. */ 1 )

      //// This method only suppresses code optimization by the compiler and does not suppresses one by hardware.

      //public: static void MemoryReadWriteBarrier();

#endif

#if( /* //{public GetVolatileValue}. */ 1 )

      //// This method only suppresses code optimization by the compiler and does not suppresses one by hardware.
      //// This method is only concerned with reading from the specified variable and doesn't ensure any acquire/release semantics.
      //// For performance, this method should be used for primitive data types only.
      //// Although the compiler might be able to optimize complex data type instance manipulation.
      //// For complex data types, we might need the parameter to be a reference, lvalue or rvalue.
      //// The caller can explicitly cross a memory barrier instead of calling this method.
      //// yg? Therefore consider eliminating this method.

      //public:
      //   template
      //      < typename TValue_
      //      >
      //   static TValue_ GetVolatileValue
      //      ( TValue_ const & value
      //      );

#endif
#if( /* //{public SetVolatileValue}. */ 1 )

      //// This method only suppresses code optimization by the compiler and does not suppresses one by hardware.
      //// This method is only concerned with writing to the specified variable and doesn't ensure any acquire/release semantics.
      //// For performance, this method should be used for primitive data types only.
      //// Although the compiler might be able to optimize complex data type instance manipulation.
      //// For complex data types, we might need 1 or both parameters to be references, lvalue or rvalue.
      //// The caller can explicitly cross a memory barrier instead of calling this method.
      //// yg? Therefore consider eliminating this method.

      //public:
      //   template
      //      < typename TValue_
      //      >
      //   static void SetVolatileValue
      //      ( TValue_ & destinationValue,
      //        TValue_ sourceValue
      //      );

#endif
   };
}
}
