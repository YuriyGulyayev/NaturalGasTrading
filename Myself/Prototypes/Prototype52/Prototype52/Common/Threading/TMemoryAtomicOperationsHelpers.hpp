#pragma once

//#include "./.hpp"

#include "../SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Common
{
namespace Threading
{
   // yg? Full memory barrier is currently not supported.
   // yg? Although the methods are atomic they have no word {Atomic} in their names (the class has).
   // TODO 3 yg? I believe an acquire memory barrier is faster than a release one. To be tested if needed.
   // TODO 3 yg? Replace some {::Interlocked...} functions with more efficient compiler intrinsics.
   // yg? Does this class belong to the {Threading} namespace? Consider moving these methods to something like
   // yg? {Synchronization} or {ThreadsSynchronization} namespace or helper class.
   // yg? Consider merging this class with {CodeOptimization::TCodeOptimizationHelpers}
   // yg? or at least coordinate refactoring of the classes.
   // yg? Consider renaming this class to {TMemoryModelHelpers}. But the word "atomic" should stay there too.
   // yg? Consider removing the word {Memory} from this class name as I don't use it elsewhere. Maybe it's OK.

   class TMemoryAtomicOperationsHelpers abstract sealed
   {
#if( /* //{(private)} Instance default constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* //{(private)} Instance copy constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* //{(private) operator =}. */ 1 )

      // Cannot be autogenerated.

#endif

#if( /* //{public MemoryAcquireBarrier}. */ 1 )

      //// yg? Consider moving this method to {TThreadingHelpers}.

      //public: static void MemoryAcquireBarrier();

#endif
#if( /* //{public MemoryReleaseBarrier}. */ 1 )

      //// yg? Consider moving this method to {TThreadingHelpers}.

      //public: static void MemoryReleaseBarrier();

#endif
#if( /* //{public MemoryFullBarrier}. */ 1 )

      //// yg? Consider moving this method to {TThreadingHelpers}.

      //public: static void MemoryFullBarrier();

#endif

#if( /* //{public GetValue}. */ 1 )

      //// Any pending non-atomic writes to this variable will be flushed before its value is read.
      //// It's undefined if any other pending non-atomic writes will be flushed or any memory barrier will be crossed.

      //public: static int GetValue
      //   ( int /*volatile*/ const & value
      //   );

#endif
#if( /* //{public SetValue}. */ 1 )

      //// The new value will immediately become visible to all processors.
      //// It's undefined if any other pending non-atomic writes will become visible to all processors or any memory barrier will be crossed.

      //public: static void SetValue
      //   ( int /*volatile*/ & destinationValue,
      //     int sourceValue
      //   );

#endif

#if( /* {public GetAndSetValueWithMemoryAcquireBarrier}. */ 1 )

      // Returns the initial value of {destinationValue}.

      public: static int GetAndSetValueWithMemoryAcquireBarrier
         ( int /*volatile*/ & destinationValue,
           int sourceValue
         );

#endif
#if( /* {public GetAndSetValueIfEqualsWithMemoryAcquireBarrier}. */ 1 )

      // Returns the initial value of {destinationValue}, changed or not.
      // yg? This method is overloaded on both numeric and pointer types.

      public: static int GetAndSetValueIfEqualsWithMemoryAcquireBarrier
         ( int /*volatile*/ & destinationValue,
           int sourceValue,
           int destinationValueComperand
         );

#endif
#if( /* {public GetAndSetValueIfEqualsWithMemoryAcquireBarrier}. */ 1 )

      // Returns the initial value of {destinationValue}, changed or not.
      // yg? This method is overloaded on both numeric and pointer types.

      public: static void * GetAndSetValueIfEqualsWithMemoryAcquireBarrier
         ( void * /*volatile*/ & destinationValue,
           void * sourceValue,
           void * destinationValueComperand
         );

#endif
#if( /* {public IncrementAndGetValueWithMemoryAcquireBarrier}. */ 1 )

      //

      public: static int IncrementAndGetValueWithMemoryAcquireBarrier
         ( int /*volatile*/ & value1
         );

#endif
#if( /* {public DecrementAndGetValueWithMemoryAcquireBarrier}. */ 1 )

      //

      public: static int DecrementAndGetValueWithMemoryAcquireBarrier
         ( int /*volatile*/ & value1
         );

#endif
#if( /* {public GetAndSetValueWithMemoryReleaseBarrier}. */ 1 )

      // Returns the initial value of {destinationValue}.

      public: static int GetAndSetValueWithMemoryReleaseBarrier
         ( int /*volatile*/ & destinationValue,
           int sourceValue
         );

#endif
#if( /* {public GetAndSetValueIfEqualsWithMemoryReleaseBarrier}. */ 1 )

      // Returns the initial value of {destinationValue}, changed or not.
      // yg? This method is overloaded on both numeric and pointer types.

      public: static int GetAndSetValueIfEqualsWithMemoryReleaseBarrier
         ( int /*volatile*/ & destinationValue,
           int sourceValue,
           int destinationValueComperand
         );

#endif
#if( /* {public GetAndSetValueIfEqualsWithMemoryReleaseBarrier}. */ 1 )

      // Returns the initial value of {destinationValue}, changed or not.
      // yg? This method is overloaded on both numeric and pointer types.

      public: static void * GetAndSetValueIfEqualsWithMemoryReleaseBarrier
         ( void * /*volatile*/ & destinationValue,
           void * sourceValue,
           void * destinationValueComperand
         );

#endif
#if( /* {public IncrementAndGetValueWithMemoryReleaseBarrier}. */ 1 )

      //

      public: static int IncrementAndGetValueWithMemoryReleaseBarrier
         ( int /*volatile*/ & value1
         );

#endif
#if( /* {public DecrementAndGetValueWithMemoryReleaseBarrier}. */ 1 )

      //

      public: static int DecrementAndGetValueWithMemoryReleaseBarrier
         ( int /*volatile*/ & value1
         );

#endif
#if( /* {public GetAndSetValueWithoutMemoryBarrier}. */ 1 )

      // Returns the initial value of {destinationValue}.

      public: static int GetAndSetValueWithoutMemoryBarrier
         ( int /*volatile*/ & destinationValue,
           int sourceValue
         );

#endif
#if( /* {public GetAndSetValueIfEqualsWithoutMemoryBarrier}. */ 1 )

      // Returns the initial value of {destinationValue}, changed or not.
      // yg? This method is overloaded on both numeric and pointer types.

      public: static int GetAndSetValueIfEqualsWithoutMemoryBarrier
         ( int /*volatile*/ & destinationValue,
           int sourceValue,
           int destinationValueComperand
         );

#endif
#if( /* {public GetAndSetValueIfEqualsWithoutMemoryBarrier}. */ 1 )

      // Returns the initial value of {destinationValue}, changed or not.
      // yg? This method is overloaded on both numeric and pointer types.

      public: static void * GetAndSetValueIfEqualsWithoutMemoryBarrier
         ( void * /*volatile*/ & destinationValue,
           void * sourceValue,
           void * destinationValueComperand
         );

#endif
#if( /* {public IncrementAndGetValueWithoutMemoryBarrier}. */ 1 )

      //

      public: static int IncrementAndGetValueWithoutMemoryBarrier
         ( int /*volatile*/ & value1
         );

#endif
#if( /* {public DecrementAndGetValueWithoutMemoryBarrier}. */ 1 )

      //

      public: static int DecrementAndGetValueWithoutMemoryBarrier
         ( int /*volatile*/ & value1
         );

#endif
   };
}
}
