#pragma once

//#include "./.hpp"

#include "../SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Common
{
namespace Threading
{
   // yg? Consider renaming this namespace to {ThreadingFacade}.

   class TThreadingHelpers abstract sealed
   {
#if( /* //{(private)} Instance default constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* //{(private)} Instance copy constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* //{(private) operator =}. */ 1 )

      // Cannot be autogenerated.

#endif

#if( /* {public SleepMillisecond}. */ 1 )

      // Waits for the next multimedia timer tick.
      // The timer ticks 1024 times a second but the caller must call {::timeBeginPeriod} or {::timeSetEvent}.
      // Implications of this:
      // 1. The sleeping time span is always less than a millisecond by a considerable margin (besides it can be almost 0).
      // 2. The multimedia time can stay unchanged.
      // yg? On Linux, the sleeping can be interrupted by a signal.
      // Returns {false} if the sleeping was interrupted, which cannot happen on Windows.
      // yg? Consider returning {true} if the sleeping was interrupted. Bad idea.
      // TODO 3 yg? Use {::NtDelayExecution}.

      public: static bool SleepMillisecond();

#endif
#if( /* {public SleepMilliseconds}. */ 1 )

      // Waits for the multimedia time to change by {timeSpanMilliseconds}.
      // Does nothing when {timeSpanMilliseconds <= 0}.
      // TODO 2 yg? Remember to call {DoSleepMilliseconds} instead of {SleepMilliseconds} when appropriate.
      // The timer ticks 1024 times a second but the caller must call {::timeBeginPeriod} or {::timeSetEvent}.
      // Implications of this:
      // 1. The sleeping time span can be less or greater than the given milliseconds by a considerable margin.
      // If {timeSpanMilliseconds} is close to overflow or the system hibernates for a long time the behavior is officially undefined.
      // Infinite sleeping is not supported.
      // yg? These methods should be renamed to {AccurateSleep...} and we need counterpart methods named simply {Sleep...}
      // yg? to favor performance over accuracy. They would simply call {::Sleep} or {::Poco::Thread::sleep}.
      // TODO 3 yg? Use {::NtDelayExecution}.

      public: static void SleepMilliseconds
         ( int timeSpanMilliseconds
         );

#endif
#if( /* {public DoSleepMilliseconds}. */ 1 )

      // Assumption: {timeSpanMilliseconds > 0}.
      // TODO 2 yg? Remember to call {DoSleepMilliseconds} instead of {SleepMilliseconds} when appropriate.

      public: static void DoSleepMilliseconds
         ( int timeSpanMilliseconds
         );

#endif
#if( /* {public SleepUntilMultimediaTimeMilliseconds}. */ 1 )

      // Implemented the same way as the {SleepMilliseconds} method.

      public: static void SleepUntilMultimediaTimeMilliseconds
         ( int endTimeMilliseconds
         );

#endif
   };
}
}
