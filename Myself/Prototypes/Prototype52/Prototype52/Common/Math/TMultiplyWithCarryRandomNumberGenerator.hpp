#pragma once

//#include "./.hpp"

#include "../SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Common
{
namespace Math
{
   // Multiply-With-Carry random number generator.
   // My algorithm uses 2 lag-1 (might be referred to as lag-0) sequences and combines them to make a pseudo-random number.
   // This class doesn't automatically seed itself, however the {TMultiplyWithCarryRandomNumberCommonGenerator} class does.
   // This implementation will survive concurrent calls on multiple threads provided 32-bit integeer read and write are atomic
   // and intermediary values are stored elsewhere. But the behavior can be skewed in a variety of ways,
   // including different threads or consequitive calls on one thread generating the same random number.
   // One workaround is to bitwise x-or the result with thread ID.
   // yg? We might need a 64-bit version but it would be more or less thread safe only if 64-bit integeer read and write were atomic.
   // yg? Consider moving this class to a separate namespace, like I did in a past C# project. Or was it a namespace
   // yg? dedicated to unique IDs?
   // yg? In C#, this probably should be a {struct}.
   // See the prototype methods at the end of the ".cpp" file.
   // Links:
   //    http://en.wikipedia.org/wiki/Multiply-with-carry
   //    http://www.ms.uky.edu/~mai/RandomNumber
   //    http://www.rlmueller.net/MWC32.htm
   //
   // Ideas.
   // @ Use linear congruential generator. See {LinearCongruentialGeneratorPrototype}.

   class TMultiplyWithCarryRandomNumberGenerator
   {
#if( /* {private ValueZMultiplier_}. */ 1 )

      //
      private: static unsigned int const ValueZMultiplier_ = 65184U;

#endif
#if( /* {private ValueWMultiplier_}. */ 1 )

      //
      private: static unsigned int const ValueWMultiplier_ = 64860U;

#endif
#if( /* {private ValueZBadSeed1_}. */ 1 )

      //
      private: static unsigned int const ValueZBadSeed1_ = 0U;

#endif
#if( /* {private ValueWBadSeed1_}. */ 1 )

      //
      private: static unsigned int const ValueWBadSeed1_ = 0U;

#endif
#if( /* {private ValueZBadSeed2_}. */ 1 )

      //
      private: static unsigned int const ValueZBadSeed2_ = ( ( ValueZMultiplier_ - 1U ) << 16U ) | 0xFFFFU;

#endif
#if( /* {private ValueWBadSeed2_}. */ 1 )

      //
      private: static unsigned int const ValueWBadSeed2_ = ( ( ValueWMultiplier_ - 1U ) << 16U ) | 0xFFFFU;

#endif
#if( /* {private ValueZAdjustment_}. */ 1 )

      //
      private: static unsigned int const ValueZAdjustment_ =
         ( ( 0xFFFFFFFFU - ( ValueZBadSeed2_ - 1U ) ) - ( ValueZBadSeed1_ + 1U ) ) / 2U;

#endif
#if( /* {private ValueWAdjustment_}. */ 1 )

      //
      private: static unsigned int const ValueWAdjustment_ =
         ( ( 0xFFFFFFFFU - ( ValueWBadSeed2_ - 1U ) ) - ( ValueWBadSeed1_ + 1U ) ) / 2U;

#endif
#if( /* {private ValueZ_}. */ 1 )

      // The 1st lag-1 sequence.
      // This value must be from {ValueZBadSeed1_ + 1U} to {ValueZBadSeed2_ - 1U}.
      private: unsigned int ValueZ_;

#endif
#if( /* {private ValueW_}. */ 1 )

      // The 2nd lag-1 sequence.
      // This value must be from {ValueWBadSeed1_ + 1U} to {ValueWBadSeed2_ - 1U}.
      private: unsigned int ValueW_;

#endif

#if( /* {(public)} Instance default constructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* {(public)} Instance copy constructor. */ 1 )

      // Could be autogenerated.
      // We don't need an instance move constructor.

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* {(public) operator =}. */ 1 )

      // Could be autogenerated.
      // We don't need a move assignment operator.

#endif

#if( /* {public ValueZ}. */ 1 )

      //

      public: unsigned int ValueZ() const;

#endif
#if( /* {public ValueW}. */ 1 )

      //

      public: unsigned int ValueW() const;

#endif
#if( /* {public SafeSeedValueZ}. */ 1 )

      // This method is named "safe" as it scales {valueZSeed} down to ensure that it's within the correct range.

      public: void SafeSeedValueZ
         ( unsigned int valueZSeed
         );

#endif
#if( /* {public SafeSeedValueW}. */ 1 )

      // This method is named "safe" as it scales {valueWSeed} down to ensure that it's within the correct range.

      public: void SafeSeedValueW
         ( unsigned int valueWSeed
         );

#endif
#if( /* {public UnsafeSeedValueZ}. */ 1 )

      // This method is named "unsafe" as doesn't check that {valueZSeed} is within the correct range.

      public: void UnsafeSeedValueZ
         ( unsigned int valueZSeed
         );

#endif
#if( /* {public UnsafeSeedValueW}. */ 1 )

      // This method is named "unsafe" as doesn't check that {valueWSeed} is within the correct range.

      public: void UnsafeSeedValueW
         ( unsigned int valueWSeed
         );

#endif
#if( /* {public Reseed}. */ 1 )

      // This method uses a default logic to seed the object.

      public: void Reseed();

#endif
#if( /* {public AdvanceValueZ}. */ 1 )

      //

      public: void AdvanceValueZ();

#endif
#if( /* {public AdvanceValueW}. */ 1 )

      //

      public: void AdvanceValueW();

#endif

#if( /* {public GenerateMediumQuality32Bits}. */ 1 )

      //

      public: unsigned int GenerateMediumQuality32Bits();

#endif
#if( /* {public GenerateHighQuality16Bits}. */ 1 )

      // It's more efficient to call {GenerateHighQuality16BitsRaw}.

      public: unsigned int GenerateHighQuality16Bits();

#endif
#if( /* {public GenerateHighQuality16BitsRaw}. */ 1 )

      // The "raw" means that the higher order 16 bits can be a nonzero. The caller should not use them.

      public: unsigned int GenerateHighQuality16BitsRaw();

#endif
#if( /* {public GenerateLowQuality16Bits}. */ 1 )

      // This method advances only {ValueZ}, which implies a short period and the potential to compromize the randomness of
      // other random number generation methods. An alternative is to call {GenerateHighQuality16Bits} or
      // {GenerateMediumQuality32Bits}.
      // It's more efficient to call {GenerateLowQuality16BitsRaw}.

      public: unsigned int GenerateLowQuality16Bits();

#endif
#if( /* {public GenerateLowQuality16BitsRaw}. */ 1 )

      // The "raw" means that the higher order 16 bits can be a nonzero. The caller should not use them.

      public: unsigned int GenerateLowQuality16BitsRaw();

#endif
#if( /* {public GenerateLowQuality1Bit}. */ 1 )

      // Although the quality is labelled "low" it's often good enough for a single bit.
      // The caller can use any bit among the returned lower order 16 bits.
      // However the quality of a combination of multiple bits is indeed low.
      // This method wraps a call to {GenerateLowQuality16Bits}. See that method comment.
      // It's more efficient to call {GenerateLowQuality1BitRaw}.
      // yg? Consider using the word "good enough" instead of "low".

      public: unsigned int GenerateLowQuality1Bit();

#endif
#if( /* {public GenerateLowQuality1BitRaw}. */ 1 )

      // This method wraps a call to {GenerateLowQuality16BitsRaw}. See that method comment.

      public: unsigned int GenerateLowQuality1BitRaw();

#endif

#if( /* {public operator ()}. */ 1 )

      // Calls {GenerateMediumQuality32Bits}.

      public: unsigned int operator () ();

#endif
   };
}
}
