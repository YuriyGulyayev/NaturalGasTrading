#pragma once

//#include "./.hpp"

#include "../SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Common
{
namespace Math
{
   //

   class TMathHelpers abstract sealed
   {
#if( /* //{(private)} Instance default constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* //{(private)} Instance copy constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* //{(private) operator =}. */ 1 )

      // Cannot be autogenerated.

#endif

#if( /* {public AssignMinValue}. */ 1 )

      // TODO 3 yg? We might also need an overload or a method with a different name that accepts a
      // TODO 3 yg? {TValue_ const && value2}, {TValue_ && value2}.
      // TODO 3 yg? Some of those would need to use perfect forwarding.
      // TODO 3 yg? Perhaps we don't even need an overload that accepts a {TValue_ value2}.

      public:
         template
            < typename TValue_
            >
         static void AssignMinValue
            ( TValue_ & value1,
              TValue_ value2
            );

#endif
#if( /* {public AssignMaxValue}. */ 1 )

      // yg? See {AssignMinValue} comment.

      public:
         template
            < typename TValue_
            >
         static void AssignMaxValue
            ( TValue_ & value1,
              TValue_ value2
            );

#endif

#if( /* //{public CircularBitwiseShiftValueRight}. */ 1 )

      ////
      //
      //public:
      //   template
      //      < typename TUnsignedInteger_
      //      >
      //   static TUnsignedInteger_ CircularBitwiseShiftValueRight
      //      ( TUnsignedInteger_ value,
      //        unsigned int offset
      //      );

#endif

#if( /* {public RoundValueToIntegerMidpointAwayFromZero}. */ 1 )

   #if( _MSC_VER != 1600 )
      #error yg?? The rounding functionality is supposed to be provided by a standard API. See {::std::nearbyint}, {::std::round}, etc.
   #endif

      // yg? The most correct rounding would probably be to round towards the smallest between {ceil( x ) - x} and {x - floor( x )}.
      // yg? This implies that {floor( x + 0.5 )} or the more efficient implementations that round to an integral data type are incorrect.
      // TODO 3 yg? Given that all rounding methods are inline, it would probably be more correct to refactor them to accept a
      // TODO 3 yg? {TValue_ const && value}.

      public:
         template
            < typename TValue_
            >
         static TValue_ RoundValueToIntegerMidpointAwayFromZero
            ( TValue_ value
            );

#endif
#if( /* {public RoundValueToIntegerMidpointAwayFromZero}. */ 1 )

      // yg? See {RoundValueToIntegerMidpointAwayFromZero<>} comment.

      public:
         template
            < typename TValue_,
               typename TInteger_
            >
         static TInteger_ RoundValueToIntegerMidpointAwayFromZero
            ( TValue_ value
            );

#endif
#if( /* {public RoundValueToMultipleOfMidpointAwayFromZero}. */ 1 )

      // yg? The rounding to a multiple involves a division, which can be optimized by pre-calculating {1.0 / valueDivisor}.
      // yg? Consider doing this in some places where performance is critical.
      // yg? We might also need a sort of {RoundValueToDecimalPlaces...} method.
      // yg? See {RoundValueToIntegerMidpointAwayFromZero<>} comment.

      public:
         template
            < typename TValue_
            >
         static TValue_ RoundValueToMultipleOfMidpointAwayFromZero
            ( TValue_ value,
              TValue_ valueDivisor
            );

#endif
#if( /* {public RoundValueToIntegerMidpointTowardsZero}. */ 1 )

      // yg? See {RoundValueToIntegerMidpointAwayFromZero<>} comment.

      public:
         template
            < typename TValue_
            >
         static TValue_ RoundValueToIntegerMidpointTowardsZero
            ( TValue_ value
            );

#endif
#if( /* {public RoundValueToIntegerMidpointTowardsZero}. */ 1 )

      // yg? See {RoundValueToIntegerMidpointAwayFromZero<>} comment.

      public:
         template
            < typename TValue_,
               typename TInteger_
            >
         static TInteger_ RoundValueToIntegerMidpointTowardsZero
            ( TValue_ value
            );

#endif
#if( /* {public RoundValueToMultipleOfMidpointTowardsZero}. */ 1 )

      // yg? See {RoundValueToIntegerMidpointAwayFromZero<>} comment.
      // yg? See {RoundValueToMultipleOfMidpointAwayFromZero<>} comment.

      public:
         template
            < typename TValue_
            >
         static TValue_ RoundValueToMultipleOfMidpointTowardsZero
            ( TValue_ value,
              TValue_ valueDivisor
            );

#endif
#if( /* {public RoundValueToIntegerMidpointDown}. */ 1 )

      // yg? See {RoundValueToIntegerMidpointAwayFromZero<>} comment.

      public:
         template
            < typename TValue_
            >
         static TValue_ RoundValueToIntegerMidpointDown
            ( TValue_ value
            );

#endif
#if( /* {public RoundValueToIntegerMidpointDown}. */ 1 )

      // yg? See {RoundValueToIntegerMidpointAwayFromZero<>} comment.

      public:
         template
            < typename TValue_,
               typename TInteger_
            >
         static TInteger_ RoundValueToIntegerMidpointDown
            ( TValue_ value
            );

#endif
#if( /* {public RoundValueToMultipleOfMidpointDown}. */ 1 )

      // yg? See {RoundValueToIntegerMidpointAwayFromZero<>} comment.
      // yg? See {RoundValueToMultipleOfMidpointAwayFromZero<>} comment.

      public:
         template
            < typename TValue_
            >
         static TValue_ RoundValueToMultipleOfMidpointDown
            ( TValue_ value,
              TValue_ valueDivisor
            );

#endif
#if( /* {public RoundNonPositiveValueToIntegerMidpointDown}. */ 1 )

      // yg? See {RoundValueToIntegerMidpointAwayFromZero<>} comment.

      public:
         template
            < typename TValue_,
               typename TInteger_
            >
         static TInteger_ RoundNonPositiveValueToIntegerMidpointDown
            ( TValue_ value
            );

#endif
#if( /* {public RoundValueToIntegerMidpointUp}. */ 1 )

      // yg? See {RoundValueToIntegerMidpointAwayFromZero<>} comment.

      public:
         template
            < typename TValue_
            >
         static TValue_ RoundValueToIntegerMidpointUp
            ( TValue_ value
            );

#endif
#if( /* {public RoundValueToIntegerMidpointUp}. */ 1 )

      // yg? See {RoundValueToIntegerMidpointAwayFromZero<>} comment.

      public:
         template
            < typename TValue_,
               typename TInteger_
            >
         static TInteger_ RoundValueToIntegerMidpointUp
            ( TValue_ value
            );

#endif
#if( /* {public RoundValueToMultipleOfMidpointUp}. */ 1 )

      // yg? See {RoundValueToIntegerMidpointAwayFromZero<>} comment.
      // yg? See {RoundValueToMultipleOfMidpointAwayFromZero<>} comment.

      public:
         template
            < typename TValue_
            >
         static TValue_ RoundValueToMultipleOfMidpointUp
            ( TValue_ value,
              TValue_ valueDivisor
            );

#endif
#if( /* {public RoundNonNegativeValueToIntegerMidpointUp}. */ 1 )

      // yg? See {RoundValueToIntegerMidpointAwayFromZero<>} comment.

      public:
         template
            < typename TValue_,
               typename TInteger_
            >
         static TInteger_ RoundNonNegativeValueToIntegerMidpointUp
            ( TValue_ value
            );

#endif
#if( /* //{RoundValuePrototype}. */ 0 )

      // Placeholder.

#endif

#if( /* {public ScaleNumber}. */ 1 )

      // {number} can be any possible value. It will be shrinked.
      // Assumption: {scaledNumberMinLimit <= scaledNumberMaxLimit}.

      public: static unsigned int ScaleNumber
         ( unsigned int number,
           unsigned int scaledNumberMinLimit,
           unsigned int scaledNumberMaxLimit
         );

#endif

#if( /* {public CalculateCheckSum}. */ 1 )

      //

      public: static unsigned int CalculateCheckSum
         ( unsigned int const * dataBegin,
           //unsigned int const * dataEnd,
           int dataLength,
           unsigned int initialCheckSum
           //unsigned int shiftInitialOffset
         );

#endif

#if( /* {public CalculateNextCheapMovingAverage}. */ 1 )

      // This method ensures that {cheapMovingAverage1} will converge to {value1} in case the later stops changing.
      // {TCheapMovingAverage_} shall be a floating point data type.
      // TODO 3 yg? The parameters should be {const} rvalue references.

      public:
         template
            < typename TCheapMovingAverage_
            >
         static TCheapMovingAverage_ CalculateNextCheapMovingAverage
            ( TCheapMovingAverage_ cheapMovingAverage1,
              TCheapMovingAverage_ value1,
              TCheapMovingAverage_ factor2
            );

#endif
   };
}
}
