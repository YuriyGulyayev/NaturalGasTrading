#pragma once

#include "./TInstrumentAggregatedQuote.hpp"
#include "./TInstrumentBestAggregatedBidAskQuoteItemsBitMask.hpp"

#include "../../Common/SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Finance
{
namespace MarketData
{
   // It's possible that when a new event arrives from the brokerage API no new data actually becomes available
   // and instead all old data gets invalidated. In that case it's implementation defined if the timestamps will be updated.
   // yg? Is it a good idea to add timestamps related bits in the validity bitmask to reflect that?
   // yg? This class does not have a non-autogenerated constructor.
   // It's probably a bad idea to maintain separate subscriptions for the bid and ask as those depend on each other
   // and should be validated against each other.
   // yg? Consider moving some members to a base class.

   class TInstrumentBestAggregatedBidAskQuote
   {
#if( /* {public Bid}. */ 1 )

      //
      public: TInstrumentAggregatedQuote Bid;

#endif
#if( /* {public Ask}. */ 1 )

      //
      public: TInstrumentAggregatedQuote Ask;

#endif
#if( /* {public GenerationDateTimeStampMillisecondsSince1970}. */ 1 )

      // When the brokerage or the exchange generated the last data update.
      // In case the brokerage API does not provide this date-time-stamp the value will stay
      // {::Common::Time::TTimeHelpers::MinTimeStamp.epochMicroseconds() / ::Poco::Timespan::MILLISECONDS}.
      // TODO 3 yg? The data type of this field should be {::Poco::Int64}; it should be expressed in milliseconds, microseconds,
      // TODO 3 yg? or 100 nanoseconds; it should be an offset from an earlier year.
      public: double GenerationDateTimeStampMillisecondsSince1970;

#endif
#if( /* {public SendingDateTimeStampMillisecondsSince1970}. */ 1 )

      // When the brokerage or the exchange sent the last data update.
      // yg? See {GenerationDateTimeStampMillisecondsSince1970} comment.
      public: double SendingDateTimeStampMillisecondsSince1970;

#endif
#if( /* {public LastUpdatedItemsBitMask}. */ 1 )

      // Specifies what items arrived in the last update.
      // Can potentially be {TInstrumentBestAggregatedBidAskQuoteItemsBitMask_None}.
      public: TInstrumentBestAggregatedBidAskQuoteItemsBitMask LastUpdatedItemsBitMask;

#endif
#if( /* {public ItemsValidityBitMask}. */ 1 )

      // Specifies what items are valid, which usually means real-time (not historical), tradable, and not any sort of indicative.
      public: TInstrumentBestAggregatedBidAskQuoteItemsBitMask ItemsValidityBitMask;

#endif

#if( /* {(public)} Instance default constructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* {(public)} Instance copy constructor. */ 1 )

      // Could be autogenerated.
      // We don't need an instance move constructor.

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* {(public) operator =}. */ 1 )

      // Could be autogenerated.
      // We don't need a move assignment operator.

#endif

#if( /* {public Reset}. */ 1 )

      //

      public: void Reset();

#endif
#if( /* {public Equals}. */ 1 )

      // yg? We might also need {operator ==}.

// todo Rename to {Equal}?
      public: static bool Equals
         ( TInstrumentBestAggregatedBidAskQuote const & instance1,
           TInstrumentBestAggregatedBidAskQuote const & instance2
         );

#endif

#if( /* {public PricesSpread}. */ 1 )

      // Assumption: both bid and ask prices are valid.
      // Even if both bid and ask prices are properly rounded their difference is not guaranteed to be such
      // in case the operands are different.

      public: double PricesSpread();

#endif
   };
}
}
