#pragma once

#include "./TFileSystemCacheFlusherConfiguration.hpp"

#include "../Common/SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Prototype52
{
   // yg? This implementation is a hack and serves only our immediate needs.
   // yg? I don’t want to move this hack to a more common namespace.
   // yg? Idea: flush on another thread; log the timing; log "sync.exe" return code.

   class TFileSystemCacheFlusher
   {
#if( /* {private FileSystemCacheFlushingApplicationFilePathName_}. */ 1 )

      //
      private: ::std::string FileSystemCacheFlushingApplicationFilePathName_;

#endif

#if( /* {public} Instance default constructor. */ 1 )

      //

      public: explicit TFileSystemCacheFlusher();

#endif
#if( /* {private} Instance copy constructor. */ 1 )

      //

      private: explicit TFileSystemCacheFlusher
         ( TFileSystemCacheFlusher const & source
         );

#endif
#if( /* {public} Instance constructor. */ 1 )

      //

      public: explicit TFileSystemCacheFlusher
         ( TFileSystemCacheFlusherConfiguration && configuration1
         );

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.

#endif
#if( /* {private operator =}. */ 1 )

      //

      private: TFileSystemCacheFlusher & operator =
         ( TFileSystemCacheFlusher const & source
         );

#endif

#if( /* {public Initialize}. */ 1 )

      //

      public: void Initialize
         ( TFileSystemCacheFlusherConfiguration && configuration1
         );

#endif
#if( /* {private DoInitialize}. */ 1 )

      //

      private: void DoInitialize
         ( //TFileSystemCacheFlusherConfiguration && configuration1
         );

#endif
#if( /* {public AsyncRun}. */ 1 )

      // This method may be called multiple times.
      // yg? Idea: if previous call is still running, log an "Error;" and do nothing. And rename it to {AsyncRunIfNotRunning}.

      public: void AsyncRun();

#endif
   };
}
