#pragma once

#include "./TStrategyBase.hpp"
#include "./TStrategyFactoryConfiguration.hpp"

#include "../Common/SourceCodeModel/IncrementHeaderInclusionBalance.hpp"

namespace Prototype52
{
   // yg? Do we need base template classes for this and related classes.

   class TStrategyFactory
   {
#if( /* {public Strategy}. */ 1 )

      //
      public: ::std::unique_ptr< TStrategyBase > Strategy;

#endif

#if( /* //{(private)} Instance default constructor. */ 1 )

      // Cannot be autogenerated.

#endif
#if( /* {private} Instance copy constructor. */ 1 )

      //

      private: explicit TStrategyFactory
         ( TStrategyFactory const & source
         );

#endif
#if( /* {public} Instance constructor. */ 1 )

      //

      public: explicit TStrategyFactory
         ( ::Common::ControlFlow::TThreadedActivityCancellationToken & threadedActivityCancellationToken1,
           TStrategyFactoryConfiguration && configuration1
         );

#endif
#if( /* {(public)} Instance destructor. */ 1 )

      // Could be autogenerated.
      // yg? It would probably be OK to not make this {virtual} even if I make this class a part of an inheritance hierarchy.

#endif
#if( /* {private operator =}. */ 1 )

      //

      private: TStrategyFactory & operator =
         ( TStrategyFactory const & source
         );

#endif

#if( /* {private CreateStrategy}. */ 1 )

      // The caller shall {delete} the pointer returned.

      private: static TStrategyBase * CreateStrategy
         ( ::Common::ControlFlow::TThreadedActivityCancellationToken & threadedActivityCancellationToken1,
           TStrategyFactoryConfiguration && configuration1
         );

#endif
   };
}
